@startuml
'https://plantuml.com/sequence-diagram
!include ../Style.puml

autonumber 7.1

participant "planList\n:PlanList" AS pl
participant "workoutList\n:WorkoutList" AS wl

activate pl
group sd Write new Plan data into file on user's system.
pl -> ":String" : userArgument.split("/workouts").trim()
activate ":String"
return userPlanNameInput:String
deactivate ":String"

pl -> pl : checkPlanNameValidity(userPlanNameInput)
activate pl
return :boolean

opt hasValidPlanName
create ":InvalidPlanException" AS ipe
pl -> ipe : throw new InvalidPlanException
activate ipe
return
end

pl -> ":String" : userArgument.split("/workouts").trim()
activate ":String"
return userWorkoutNumbersString:String
deactivate ":String"

pl -> ":Integer" : userWorkoutNumbersString.split(",").length
activate ":Integer"
return numberOfWorkoutsInAPlan:Integer
deactivate ":Integer"

pl -> pl : checkMinMaxNumberOfWorkouts(numberOfWorkoutsInAPlan)
activate pl
return :boolean

opt !isAppropriateNumberOfWorkouts
create ":InvalidPlanException" AS ipe
pl -> ipe : throw new InvalidPlanException
activate ipe
return
end

create "workoutsToAddInAPlanList:ArrayList<Workout>" AS wtoadd
pl -> wtoadd : new
activate wtoadd
return

loop until all workouts to be added in a plan is added (numberOfWorkoutsInAPlan)
pl -> ":Integer" : parseInt(userWorkoutNumbersString.split(",")[i].trim())
activate ":Integer"
return workoutNumberInteger:Integer
deactivate ":Integer"
pl -> pl : checkWorkoutNumberWithinRange(workoutNumberInteger)
activate pl
return :boolean
opt !isWithinWorkoutListRange
create ":InvalidPlanException" AS ipe
pl -> ipe : throw new InvalidPlanException
activate ipe
return
end
pl -> wl : getWorkoutsDisplayList().get(workoutNumberInteger - 1)
activate wl
return workoutToAddKey:String
pl -> wl : getWorkoutFromKey(workoutToAddKey)
activate wl
return workoutToAddObject:Workout
pl -> wtoadd : add(workoutToAddObject)
activate wtoadd
return
end

create "newPlan:Plan" AS newPlan
pl -> newPlan : new Plan(userPlanNameInput, workoutsToAddInAPlanList)
activate newPlan
return newPlan:Plan

pl -> newPlan : toString()
activate newPlan
return newPlanKey:String

pl -> "plansHashMapList\n:HashMap" : put(newPlanKey, newPlan)
activate "plansHashMapList\n:HashMap"
return

pl -> "plansDisplayList\n:ArrayList<String>" : add(newPlanKey)
activate "plansDisplayList\n:ArrayList<String>"
return

end
@enduml